package com.hy.basic.java.multithreading.basic.hy_lock;

import java.util.concurrent.locks.ReentrantLock;

/**
 * @user hy
 * @date sometime
 * @introduce
 **/
public class Introduce {

    public static void main(String[] args) {

        /*
                锁的分类

                这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计
         */


        /*
                公平锁/非公平锁

            公平锁指多个线程按照申请锁的顺序获得锁。
            Java ReentrantLock通过构造函数来指定锁是公平还是非公平，默认是非公平锁，对于synchronized而言，也是一种非公平锁。

            非公平锁优点在于吞吐量比公平锁大。
         */



        /*
            可重入锁

            可重入锁又叫递归锁，是指同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。举例如下：

         synchronized void setA() throws Exception{
            Thread.sleep(1000);
            setB();
        }
        synchronized void setB() throws Exception{
            Thread.sleep(1000);
        }

            ReentrantLock是一个可重入锁。（上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁）
            Synchronized也是一个可重入锁。

            可重入锁的优点是可以一定程度避免死锁。
         */


        /*
            独享锁/共享锁

            顾名思义，独享锁是指该锁一次只能被一个线程所持有，共享锁可以被多个线程所持有。

            Java reentrantlock是一个独享锁，但是对于lock的另一个实现readwritelock，其读锁是一个共享锁，写锁是一个独享锁。
            对于synchronized是一个独享锁。

         */


        /*
            互斥锁/读写锁

            上边说的独享锁和共享锁是一种广义的说法，互斥锁和读写锁就是具体实现。

            互斥锁在Java中具体实现就是reentrantlock(只能有一个线程访问该对象)。

            读写锁在Java中的具体实现就是readwritelock。

         */


        /*
            乐观锁/悲观锁

            乐观锁和悲观锁不是指具体的锁类型，而是对于看待并发编程中加锁问题的角度。

            悲观锁认为，对于一个数据的并发操作，一定会改变数据，即使实际上数据没被改变，但是也悲观的认为被改变的可能性比较大，一定要加锁，不加锁早晚要出问题。

            乐观锁认为，对于一个数据的并发操作，是不会改变数据的，不加锁也不会出问题。

            乐观锁指java中的无所编程，适合读操作非常多的场景。

            悲观锁就是指java中，适合并发下写非常多的场景。

         */


        /*
                自旋锁
            和互斥锁类似,只能有一个保持者;但是不同的是互斥锁没有拿到锁的会休眠,
            但是自旋锁会持续访问拥有自旋锁的持有者

         */


        /*
                偏向锁/轻量级锁/重量级锁

                这三种锁，就是指锁的状态，针对synchronized。

                偏向锁是指一段代码一直被一个线程所访问，那么理论上，这个线程会自动获取这个锁，并一直拥有这个锁，这样就降低了获取锁的代价。

                轻量级锁是指当偏向锁的状态下，被另一个线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋形式尝试获取锁，不会阻塞，提高效率。

                重量级锁是指在轻量级锁的状态下，另一个线程虽然自旋，但自选不会一直持续下去，当自旋一定次数的时候还没有获取到锁的话，就会进入阻塞，
                    该锁就会膨胀为重量级锁，重量级锁会让其他申请的线程陷入阻塞，降低性能。

         */

        /*
                分段锁
                首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。
                1.7及之前的ConcurrentHashMap。并发操作就是分段锁，其思想就是让锁的粒度变小。
         */

    }

}
